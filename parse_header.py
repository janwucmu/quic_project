"""
parse_header.py
Name: Janabelle Wu
Email: yunchiew@andrew.cmu.edu
==============================
Parse Hex values of the quic headers from the wireshark pcap files
"""
from scapy.all import *
import pandas as pd
from binascii import hexlify
from csv import reader

# store the special characters
special_char = {}

# dictionary of the different quic fields that should be added to the csv files
fields = {"header.form": [], "fixed.bit": [], "spin.bit": [], \
        "reserved": [], "key.bit": [], "packet.len": []}
#TODO need "dest.connect.id"


"""
Check if the columns generated by parsing matches the columns generated by tshark
"""
def check_ip_udp():
    # open file in read mode
    with open('pcapCSV/quic_parallel_check.csv', 'r') as read_obj:
        # pass the file object to reader() to get the reader object
        csv_reader = reader(read_obj)
        # skip the header
        header = next(csv_reader)

        lst = []
        # Iterate over each row in the csv using reader object
        for row in csv_reader:
            if row[3] == row[8] and row[4] == row[9] and row[5] == row[10] and row[6] == row[11] and row[7] == row[12]:
                lst.append(1)
            else:
                lst.append(0)
    print(all(lst))


"""
Reading in the exisiting csv files, adding the necessary quic fields to it, 
and export it back to the csv file
"""
def df_to_csv():
    df = pd.read_csv("pcapCSV/quic_parallel.csv", sep="\t")
    for key, value in fields.items():
        df[key] = value
    df.to_csv("pcapCSV/quic_parallel.csv", index=False, sep="\t")


"""
Take the characters that were mixed in with hex values and turn each char into hex values.

:param: lst - list of all the hex values of the packet
:param: chars - string of characters to turn into hex values using ascii
:return: lst - list of all the hex values of the packet (updated)
"""
def chars_to_hex(lst, chars):
    special = False

    # convert chars to hex
    for i in range(len(chars)):
        if chars[i] != "\\":
            if (i != 0) and (chars[i-1:i+1] in special_char.keys()):
                lst.append(special_char[chars[i-1:i+1]])
                special = False
                continue
            if special:
                lst.append(hex(ord("\\"))[2:])
            lst.append(hex(ord(chars[i]))[2:])
            special = False
        else:
            if special:
                lst.append(hex(ord("\\"))[2:])
                special = False
            else:
                special = True
    return lst


"""
Extract the ip src and ip dest from hex values representing the ip information

:param: ip - hex values representing ip information
"""
def get_ip_src_dest(ip):
    src_hex = ip[12:16]
    dest_hex = ip[16:]
    src = ""
    dest = ""
    for i in range(len(src_hex)):
        # turn hex into decimal and cast as string
        src += str(int(src_hex[i], 16)) + "."
        dest += str(int(dest_hex[i], 16)) + "."
    # exclude the last "."
    src = src[:-1]
    dest = dest[:-1]

    # store it in fields dictionary
    fields["ip_src"].append(src)
    fields["ip_dest"].append(dest)


"""
Extract the udp src port, udp dest port, udp length from hex values representing 
the udp information

:param: udp - hex values representing udp information
"""
def get_udp_src_dest(udp):
    src_hex = udp[:2]
    dest_hex = udp[2:4]
    len_hex = udp[4:6]
    src = str(int(src_hex[0] + src_hex[1], 16))
    dest = str(int(dest_hex[0] + dest_hex[1], 16))
    length = str(int(len_hex[0] + len_hex[1], 16))

    # store it in fields dictionary
    fields["udp_srcport"].append(src)
    fields["udp_destport"].append(dest)
    fields["udp_len"].append(length)


"""
Extract the header form, fixed bit, spin bit, reserved, key bit, packet length,
destination connection id from hex values representing the quic information

:param: quic - hex values representing quic information
"""
def get_quic_info(quic):
    # turn hex into binary
    first_byte = str("{0:08b}".format(int(quic[0], 16)))

    # set each corresponding field based on first byte
    fields["header.form"].append(first_byte[0])
    fields["fixed.bit"].append(first_byte[1])
    fields["spin.bit"].append(first_byte[2])
    # convert binary to decimal
    fields["reserved"].append(int(first_byte[3:5], 2))
    fields["key.bit"].append(first_byte[5])
    # convert binary to decimal
    fields["packet.len"].append(int(first_byte[6:8], 2))

    #TODO need to do dest.connet.id
    




def main():
    # read pcap file
    pkts = rdpcap("pcapFiles/quic_parallel.pcap")

    # entire hex for the pkt, key: packet number, value: list of hex values
    pkts_hex = {}

    # convert each of the packets into hex values
    for i in range(len(pkts)):
        # hex values in byte type
        byte_hex = hexlify(bytes(pkts[i]))
        # hex values converted to string
        string = str(byte_hex, 'utf-8')
        lst = []
        # split the hex values into one byte per element in the list
        for j in range(0, len(string), 2):
            lst.append(string[j:j+2])
        # store packet number into the dictionary
        pkts_hex[i] = lst

    # each packet and its hex values
    for key, values in pkts_hex.items():
        # format of wireshark hexdump
        ethernet = lst[:14]
        
        ip = values[14:34]
        # get_ip_src_dest(ip)

        udp = values[34:42]
        # get_udp_src_dest(udp)

        quic = values[42:]
        get_quic_info(quic)

    df_to_csv()
    # check_ip_udp()


if __name__ == "__main__":
    main()